
\documentclass[12pt,a4paper]{report}%especifica o tipo de documento que tenciona escrever: carta, artigo, relatório... neste caso é um relatório
% [11pt,a4paper] Define o tamanho principal das letras do documento. caso não especifique uma delas, é assumido 10pt
% a4paper -- Define o tamanho do papel.

\usepackage[portuges]{babel}%Babel -- irá activar automaticamente as regras apropriadas de hifenização para a língua todo o
                                   %-- o texto gerado é automaticamente traduzido para Português.
                                   %  Por exemplo, “chapter” irá passar a “capítulo”, “table of contents” a “conteúdo”.
                                   % portuges -- específica para o Português.
\usepackage[utf8]{inputenc} % define o encoding usado texto fonte (input)--usual "utf8" ou "latin1

\usepackage{graphicx} %permite incluir graficos, tabelas, figuras
\usepackage{url} % para utilizar o comando \url{}
\usepackage[pdftex]{hyperref} % transformar as referências internas do seu documento em hiper-ligações.
\usepackage{enumerate} %permite escolher, nas listas enumeradas, se os iems sao marcados com letras ou numeros-romanos em vez de numeracao normal

%\usepackage{apalike} % gerar biliografia no estilo 'named' (apalike)

\usepackage{xcolor} % Para escrever em cores
\usepackage{soul} % Para sombrear um texto (highlighter)
\sethlcolor{pink}
\usepackage{listings}

\lstdefinestyle{pythonStyle}{
    language=Python,
    basicstyle=\ttfamily\small,
    keywordstyle=\color{blue},
    stringstyle=\color{red},
    commentstyle=\color{gray},
    numbers=left,
    numberstyle=\tiny,
    stepnumber=1,
    numbersep=5pt,
    showstringspaces=false,
    tabsize=4,
    breaklines=true,
    breakatwhitespace=false
}

\usepackage{multirow} %tabelas com multilinhas
\usepackage{array} %formatação especial de tabelas em array

\usepackage[pdftex]{hyperref} % transformar as referências internas do seu documento em hiper-ligações.

%Exemplos de fontes -- nao e vulgar mudar o tipo de fonte
%\usepackage{tgbonum} % Fonte de letra: TEX Gyre Bonum
%\usepackage{lmodern} % Fonte de letra: Latin Modern Sans Serif
%\usepackage{helvet}  % Fonte de letra: Helvetica
%\usepackage{charter} % Fonte de letra:Charter

\definecolor{saddlebrown}{rgb}{0.55, 0.27, 0.07} % para definir uma nova cor, neste caso 'saddlebrown'

\usepackage{listings}  % para utilizar blocos de texto verbatim no estilo 'listings'
%paramerização mais vulgar dos blocos LISTING - GENERAL
\lstset{
	basicstyle=\small, %o tamanho das fontes que são usadas para o código
	numbers=left, % onde colocar a numeração da linha
	numberstyle=\tiny, %o tamanho das fontes que são usadas para a numeração da linha
	numbersep=5pt, %distancia entre a numeração da linha e o codigo
	breaklines=true, %define quebra automática de linha
    frame=tB,  % caixa a volta do codigo
	mathescape=true, %habilita o modo matemático
	escapeinside={(*@}{@*)} % o que escrever dentro destas marcas é aceite e processado como LaTeX
}
%
%\lstset{ %
%	language=Java,							% choose the language of the code
%	basicstyle=\ttfamily\footnotesize,		% the size of the fonts that are used for the code
%	keywordstyle=\bfseries,					% set the keyword style
%	%numbers=left,							% where to put the line-numbers
%	numberstyle=\scriptsize,				% the size of the fonts that are used for the line-numbers
%	stepnumber=2,							% the step between two line-numbers. If it's 1 each line
%											% will be numbered
%	numbersep=5pt,							% how far the line-numbers are from the code
%	backgroundcolor=\color{white},			% choose the background color. You must add \usepackage{color}
%	showspaces=false,						% show spaces adding particular underscores
%	showstringspaces=false,					% underline spaces within strings
%	showtabs=false,							% show tabs within strings adding particular underscores
%	frame=none,								% adds a frame around the code
%	%abovecaptionskip=-.8em,
%	%belowcaptionskip=.7em,
%	tabsize=2,								% sets default tabsize to 2 spaces
%	captionpos=b,							% sets the caption-position to bottom
%	breaklines=true,						% sets automatic line breaking
%	breakatwhitespace=false,				% sets if automatic breaks should only happen at whitespace
%	title=\lstname,							% show the filename of files included with \lstinputlisting;
%											% also try caption instead of title
%	escapeinside={\%*}{*)},					% if you want to add a comment within your code
%	morekeywords={*,...}					% if you want to add more keywords to the set
%}

\usepackage{xspace} % deteta se a seguir a palavra tem uma palavra ou um sinal de pontuaçao se tiver uma palavra da espaço, se for um sinal de pontuaçao nao da espaço

\parindent=0pt %espaço a deixar para fazer a  indentação da primeira linha após um parágrafo
\parskip=2pt % espaço entre o parágrafo e o texto anterior

\setlength{\oddsidemargin}{-1cm} %espaço entre o texto e a margem
\setlength{\textwidth}{18cm} %Comprimento do texto na pagina
\setlength{\headsep}{-1cm} %espaço entre o texto e o cabeçalho
\setlength{\textheight}{23cm} %altura do texto na pagina

% comando '\def' usado para definir abreviatura (macros)
% o primeiro argumento é o nome do novo comando e o segundo entre chavetas é o texto original, ou sequência de controle, para que expande
\def\darius{\textsf{Darius}\xspace}
\def\antlr{\texttt{AnTLR}\xspace}
\def\pe{\emph{Publicação Eletrónica}\xspace}
\def\titulo#1{\section{#1}}    %no corpo do documento usa-se na forma '\titulo{MEU TITULO}'
\def\super#1{{\em Supervisor: #1}\\ }
\def\area#1{{\em \'{A}rea: #1}\\[0.2cm]}
\def\resumo{\underline{Resumo}:\\ }

%\input{LPgeneralDefintions} %permite ler de um ficheiro de texto externo mais definições

\title{Processamento de Linguagens (3º ano de LEI)\\
       \textbf{Trabalho Prático}\\ Relatório de Desenvolvimento
       } %Titulo do documento
%\title{Um Exemplo de Artigo em \LaTeX}
\author{Diogo Neto\\ (a98197) \and Guilherme Oliveira\\ (A95021)
         \and Pedro Pacheco\\ (A61042)
       } %autores do documento
\date{1 de junho de 2025} %data

\begin{document} % corpo do documento
\maketitle % apresentar titulo, autor e data

\begin{abstract}  % resumo do documento
O presente relatório técnico tem como objetivo detalhar o processo de desenvolvimento de um compilador de linguagem pascal standard no âmbito do projeto semestral da unidade curricular.
O compilador desenvolvido recorre aos módulos lex e yacc da biblioteca ply do python e, é expectável que a gramática construída gere código assembly para a  \href{https://ewvm.epl.di.uminho.pt}{máquina virtual} disponibilizada.
\end{abstract}

\tableofcontents % Insere a tabela de indice
%\listoffigures % Insere a tabela de indice figuras
%\listoftables % Insere a tabela de indice tabelas

\chapter{Introdução} \label{chap:intro} %referência cruzada

A construção de compiladores é uma das áreas fundamentais no estudo do Processamento de Linguagens e fornece uma aplicação prática das técnicas formais de análise léxica, sintática e semântica. 
No âmbito da unidade curricular de Processamento de Linguagens, foi proposto o desenvolvimento de um compilador da linguagem Pascal, com vista à consolidação dos conhecimentos teóricos e práticos adquiridos ao longo do semestre.

O projeto visa implementar um compilador capaz de reconhecer programas válidos escritos nessa linguagem e gerar código assembly para a máquina virtual \href{https://ewvm.epl.di.uminho.pt}{EWVM}, disponibilizada pelos docentes da unidade.

O desenvolvimento do projeto foi realizado em Python, com recurso à biblioteca PLY, que permite a criação de analisadores léxicos e sintáticos com uma sintaxe própria utilizando as ferramentas lex e yacc. 

As secções seguintes detalham a implementação técnica do compilador, desde a definição da gramática até à produção de código, incluindo as metodologias adotadas e as decisões de projeto mais relevantes.



\chapter{Problema Proposto}

O principal objetivo do projeto proposto é permitir a aplicação prática dos conceitos teóricos relacionados com as várias fases de compilação: análise léxica, sintática, semântica e geração de código.

Pretende-se que a linguagem gerada para a VM suporte os seguintes elementos fundamentais:

\begin{itemize}
    \item Declaração de variáveis atómicas do tipo \texttt{integer}, \texttt{boolean} e \texttt{string}, com suporte para operações aritméticas (\texttt{+}, \texttt{-}, \texttt{*}, \texttt{div}, \texttt{mod}), relacionais (\texttt{=}, \texttt{<>}, \texttt{<}, \texttt{<=}, \texttt{>}, \texttt{>=}) e lógicas (\texttt{and}, \texttt{or}).
    
    \item Instruções algorítmicas básicas, nomeadamente atribuições de expressões a variáveis e leitura/escrita através das instruções \texttt{readln} e \texttt{writeln}, respetivamente.
    
    \item Instruções de controlo de fluxo do tipo \texttt{if-then[-else]}, permitindo decisões condicionais com base em expressões booleanas.
    
    \item Instruções de repetição, nomeadamente o ciclo \texttt{for-do}.
\end{itemize}
 
O código gerado deve preservar a semântica dos programas originais, assegurando a correta execução das instruções especificadas no destino (EWVM).

\chapter{Concepção da Resolução}
\section{Organização e Estrutura}

A implementação do nosso compilador foi organizada de forma modular, sendo dividida em quatro componentes principais de modo a refletir as diferentes fases do processo de compilação, onde cada componente desempenha um papel específico na tradução de código, sendo elas:

\begin{itemize}
    \item \textbf{Construção da Gramática Independente de Contexto}\\
    A primeira etapa consistiu na definição formal da gramática da linguagem e cobre as principais construções do pacal, aqui foram consideradas produções para declarações de variáveis, funções, expressões aritméticas e lógicas, estruturas de controlo como \texttt{if}, \texttt{while}, \texttt{for}, e chamadas de função. Esta gramática serve como base para o funcionamento do parser.
    
    \item \textbf{Construção do analisador léxico (lexer)}\\
    O módulo lexer tem como objetivo identificar os tokens válidos da linguagem, como palavras-chave (\texttt{if}, \texttt{for}, \texttt{function}), identificadores, operadores, literais, símbolos de pontuação e, para isso, foram utilizadas expressões regulares associadas a regras de tratamento de casos especiais, como literais de string e comentários.
    
    \item \textbf{Construção do analisador sintático (parser)}\\
    O analisador sintático foi desenvolvido para reconhecer sequências válidas de tokens, conforme a gramática especificada, o parser implementa regras de produção que correspondem a instruções e blocos da linguagem. 
    Além da verificação sintática, cada regra é responsável pela geração de código específico, recorrendo a instruções da VM como \texttt{PUSHI}, \texttt{STOREG}, \texttt{CALL}, entre outras.
    
    \item \textbf{Conversão para código assembly da VM}\\
    A última fase consiste na geração do código de saída, que corresponde ao código assembly da máquina virtual onde, este código, é diretamente executável por um interpretador de VM e inclui instruções para as operações descritas anteriormente. O código resultante é construído dinamicamente durante a análise sintática, sendo impresso após a conclusão da análise.
\end{itemize}

Todas as funcionalidades implementadas e descritas neste capítulo encontram-se detalhadas no \textbf{Anexo A} deste documento.


\section{GIC}
A construção do código segue as seguintes produções, com respeito rigoroso às prioridades dos operadores:
\begin{verbatim}
Programa             : PROGRAM ID SEMICOLON Block DOT
Block                : Declarations CompoundStatement
Declarations         : VarDeclarationPart FunctionDeclarations
VarDeclarationPart   : VAR VarDeclarationList
                     | empty
VarDeclarationList   : VarDeclaration
                     | VarDeclarationList VarDeclaration
VarDeclaration       : IdList COLON Type SEMICOLON
IdList               : ID
                     | ID COMMA IdList
Type                 : BasicType
                     | ArrayType
BasicType            : INTEGER
                     | STRING
                     | BOOLEAN
ArrayType            : ARRAY LBRACKET NUMBER DOTDOT NUMBER RBRACKET OF BasicType
FunctionDeclarations : FunctionDeclaration FunctionDeclarations
                     | empty
FunctionDeclaration  : FUNCTION ID LPAREN FormalParameters RPAREN COLON BasicType SEMICOLON Declarations CompoundStatement
FormalParameters     : ID COLON Type
                     | ID COLON Type SEMICOLON FormalParameters
                     | empty
CompoundStatement    : BEGIN StatementList END
StatementList        : Statement
                     | StatementList SEMICOLON Statement
Statement            : AssignmentStatement
                     | WriteStatement
                     | ReadStatement
                     | IfStatement
                     | WhileStatement
                     | ForStatement
                     | CompoundStatement
                     | empty
ReadStatement        : READLN LPAREN ArrayAccess RPAREN
                     | READLN LPAREN ID RPAREN
AssignmentStatement  : ID ASSIGN Expression
                     | ArrayAccess ASSIGN Expression
WriteStatement       : WRITELN LPAREN ExpressionList RPAREN
ExpressionList       : Expression
                     | ExpressionList COMMA Expression
Expression           : ExprBool
ExprBool             : Expr
                     | Expr OpRel Expr
OpRel                : EQ | NEQ | LT | LTE | GT | GTE
Expr                 : Termo
                     | Expr OpAd Termo
OpAd                 : PLUS | MINUS | OR
Termo                : Fator
                     | Termo OpMul Fator
OpMul                : TIMES | DIV | MOD | AND
Fator                : Const
                     | Var
                     | LPAREN ExprBool RPAREN
                     | Expression_function_call
                     | NOT Fator
Const                : NUMBER | STRING_LITERAL | TRUE | FALSE
Var                  : ID
                     | ID LBRACKET ExprBool RBRACKET
Expression_function_call : ID LPAREN ActualParameters RPAREN
                          | LENGTH LPAREN ExprBool RPAREN
ActualParameters     : ExprBool
                     | ExprBool COMMA ActualParameters
                     | empty
IfStatement          : IF Expression THEN Statement
                     | IF Expression THEN Statement ELSE Statement
WhileStatement       : WHILE Expression DO Statement
ForStatement         : FOR ID ASSIGN Expression TO Expression DO Statement
ArrayAccess          : ID LBRACKET Expression RBRACKET
empty                : (vazio)
\end{verbatim}


\section{Lexer}
O analisador léxico define tokens com expressões regulares específicas, sem recurso à abordagem de dicionário de palavras reservadas. Todas as palavras-chave da linguagem são definidas individualmente com funções do tipo:
\begin{verbatim}
def t_PROGRAM(t):
    r'program'
    return t
\end{verbatim}

A lista de tokens definidos inclui:

\begin{itemize}
  \item Palavras-chave: \texttt{PROGRAM, VAR, BEGIN, END, IF, THEN, ELSE, WHILE, DO, FOR, TO, FUNCTION, DIV, MOD, LENGTH, INTEGER, STRING, BOOLEAN, TRUE, FALSE, WRITELN, WRITE, READLN, READ, ARRAY, OF}
  \item Operadores e símbolos: \texttt{PLUS, MINUS, TIMES, ASSIGN, GT, LT, EQ, NEQ, GTE, LTE, AND, OR, NOT}
  \item Delimitadores e outros símbolos: \texttt{SEMICOLON, DOT, COLON, COMMA, LPAREN, RPAREN, LBRACKET, RBRACKET, DOTDOT}
  \item Literais e identificadores: \texttt{NUMBER, STRING\_LITERAL, ID}
\end{itemize}

Os comentários são ignorados via expressões regulares para \texttt{\{...\}} ou \texttt{(*...*)}.

\newpage
\section{Parser e conversão para assembly VM}

O analisador sintático ou parser,  é o responsável por verificar se o código pascal está escrito corretamente, isto é, se o código respeita as regras gramaticais definidas e, não havendo erros sintáticos, o parser converte o código pascal no assembly de acordo com as \href{https://ewvm.epl.di.uminho.pt/manual}{instruções}.

\subsection{Geração de assembly – Exemplo: Cálculo do Fatorial}

Através do exemplo do programa \texttt{Fatorial}, ilustramos a geração de código efetuada pelo compilador para a máquina virtual, este programa cobre instruções relacionadas com inicialização de variáveis, ciclos, entrada e saída, entre outras, o que serve para termos uma visão geral de como funcionam as instruções da VM, assim como é feita a tradução e associação das instruções pascal para as da VM.


\subsubsection{Início do Programa}

\begin{verbatim}
START
\end{verbatim}

Marca o início da execução do programa.

\subsubsection{Inicialização de Variáveis Globais}

Cada variável declarada globalmente é inicializada a 0:

\begin{verbatim}
PUSHI 0
STOREG <offset>
\end{verbatim}

Por exemplo, para:
\begin{verbatim}
var n, i, fat: integer;
\end{verbatim}
o compilador gera:
\begin{verbatim}
PUSHI 0   ; n
STOREG 0
PUSHI 0   ; i
STOREG 1
PUSHI 0   ; fat
STOREG 2
\end{verbatim}

\subsubsection{Escrita de Texto}

\begin{verbatim}
PUSHS "mensagem"
WRITES
\end{verbatim}

Corresponde à instrução:
\begin{verbatim}
writeln('Introduza um número inteiro positivo:');
\end{verbatim}

\subsubsection{Leitura de Valores (Inteiros)}

\begin{verbatim}
READ
ATOI
STOREG <offset>
\end{verbatim}

Para:
\begin{verbatim}
readln(n);
\end{verbatim}
gera-se:
\begin{verbatim}
READ
ATOI
STOREG 0
\end{verbatim}

\subsubsection{Atribuições Simples}

\begin{verbatim}
PUSHI <valor>
STOREG <offset>
\end{verbatim}

Exemplo:
\begin{verbatim}
fat := 1;
\end{verbatim}
gera:
\begin{verbatim}
PUSHI 1
STOREG 2
\end{verbatim}

\subsubsection{Ciclo \texttt{for}}

O compilador traduz ciclos do tipo:
\begin{verbatim}
for i := 1 to n do fat := fat * i;
\end{verbatim}
da seguinte forma:

\begin{verbatim}
PUSHI 1
STOREG 1         ; i := 1

L1:
PUSHG 1          ; i
PUSHG 0          ; n
INFEQ
JZ L2

PUSHG 2          ; fat
PUSHG 1          ; i
MUL
STOREG 2         ; fat := fat * i

PUSHG 1
PUSHI 1
ADD
STOREG 1         ; i := i + 1

JUMP L1
L2:
\end{verbatim}

\subsubsection{Escrita de Múltiplos Valores}

\begin{verbatim}
PUSHS "texto"
WRITES
PUSHG <offset>
WRITEI
\end{verbatim}

Exemplo:
\begin{verbatim}
writeln('Fatorial de ', n, ': ', fat);
\end{verbatim}
gera:
\begin{verbatim}
PUSHS "Fatorial de "
WRITES
PUSHG 0
WRITEI
PUSHS ": "
WRITES
PUSHG 2
WRITEI
\end{verbatim}

\subsubsection{Término do Programa}

\begin{verbatim}
STOP
\end{verbatim}

Assinala o fim do programa e termina a execução na VM.

Este exemplo demonstra como o compilador lida com as construções da linguagem pascal e as traduz eficientemente em instruções da máquina virtual, respeitando a semântica original do programa.

\chapter{Demonstração}

\section{Execução do programa}

Para inicializar o compilador, o programa desenvolvimento suporta três modos:
\begin{itemize}
    \item python yacc.py --example MaiorDe3
    
        O programa permite a execução dos seguintes programas pascal pré definidos no sistema: MaiorDe3, Fatorial, NumeroPrimo, SomaArray, HelloWorld

    \item python yacc.py --file tests/LargestOf3.pas

        Neste modo o compilador recebe programas .pas escritos pelo utilizador.

    \item python yacc.py

        Neste modo o programa lê do STDIN até ao EOF (end of file - ctrl+D)
    
\end{itemize}

O resultado dos três modos é sempre apresentado no STDOUT e pode ser validado na \href{https://ewvm.epl.di.uminho.pt}{VM} 

Durante o decorrer deste capítulo serão apresentados os porgramas mencionados no primeiro modo apresentado bem como os seus respetivos outputs devidamente testados na VM.


\section{Teste Hello World}
O programa imprime uma string "Ola, Mundo!".
\subsection{Código pascal - Hello World}

\begin{verbatim}
     program HelloWorld;
        begin
        writeln('Ola, Mundo!');
    end.
\end{verbatim}
\subsection{Código assembly - Hello World}
\begin{verbatim}
    START
    PUSHS "Ola, Mundo!"
    WRITES
    STOP
\end{verbatim}

\section{Teste Maiorde3}
O programa calcula o maior de 3 dígitos e imprime o resultado

\subsection{Código pascal - maiorde3}


\begin{verbatim}
    program Maior3;
        var  
            num1, num2, num3, maior: integer;
        begin
            { Ler 3 números }
            writeln('Introduza o primeiro número: ');  
            readln(num1);
            writeln('Introduza o segundo número: ');  
            readln(num2);
            writeln('Introduza o terceiro número: ');  
            readln(num3);
            if num1 > num2 then
                if num1 > num3 then 
                    maior := num1
                else maior := num3
            elseif num2 > num3 
                then maior := num2
            else 
                maior := num3;
            writeln(maior);
        end.
\end{verbatim}

\subsection{Código assembly gerado - maiorde3}
\begin{verbatim}
START
PUSHI 0
STOREG 0
PUSHI 0
STOREG 1
PUSHI 0
STOREG 2
PUSHI 0
STOREG 3
PUSHS "Introduza o primeiro número: "
WRITES
READ
ATOI
STOREG 0
PUSHS "Introduza o segundo número: "
WRITES
READ
ATOI
STOREG 1
PUSHS "Introduza o terceiro número: "
WRITES
READ
ATOI
STOREG 2
PUSHG 0
PUSHG 1
SUP
JZ L5
PUSHG 0
PUSHG 2
SUP
JZ L1
PUSHG 0
STOREG 3
JUMP L2
L1:
PUSHG 2
STOREG 3
L2:
JUMP L6
L5:
PUSHG 1
PUSHG 2
SUP
JZ L3
PUSHG 1
STOREG 3
JUMP L4
L3:
PUSHG 2
STOREG 3
L4:
L6:
PUSHG 3
WRITEI
STOP

\end{verbatim}

\section{Teste fatorial }
O programa calcula o fatorial de um número.
\subsection{Código pascal - fatorial }
\begin{verbatim}
     program Fatorial;
        var  
            n, i, fat: integer;
        begin  
            writeln('Introduza um número inteiro positivo:');  
            readln(n);
            fat := 1;
            for i := 1 to n do    
                fat := fat * i;
            writeln('Fatorial de ', n, ': ', fat);
        end.
\end{verbatim}

\subsection{Código assembly gerado - fatorial }
\begin{verbatim}
   START
PUSHI 0
STOREG 0
PUSHI 0
STOREG 1
PUSHI 0
STOREG 2
PUSHS "Introduza um número inteiro positivo:"
WRITES
READ
ATOI
STOREG 0
PUSHI 1
STOREG 2
PUSHI 1
STOREG 1
L1:
PUSHG 1
PUSHG 0
INFEQ
JZ L2
PUSHG 2
PUSHG 1
MUL
STOREG 2
PUSHG 1
PUSHI 1
ADD
STOREG 1
JUMP L1
L2:
PUSHS "Fatorial de "
WRITES
PUSHG 0
WRITEI
PUSHS ": "
WRITES
PUSHG 2
WRITEI
STOP
\end{verbatim}

\section{Teste NumeroPrimo}
O programa verifica se um número é par ou ímpar.
\subsection{Código pascal - NumeroPrimo}
\begin{verbatim}
     program NumeroPrimo;
        var  
            num, i: integer;  
            primo: boolean;
        begin  
            writeln('Introduza um número inteiro positivo:');  
            readln(num);  
            primo := true;  
            i := 2;
            while (i <= (num div 2)) and primo do
                begin
                    if (num mod i) = 0 then            
                        primo := false;        
                    i := i + 1;
                end;
            if primo then    
                writeln(num, ' é um número primo')
            else    
                writeln(num, ' não é um número primo');
        end.
\end{verbatim}

\subsection{Código assembly gerado - NumerpPrimo}
\begin{verbatim}
 START
PUSHI 0
STOREG 0
PUSHI 0
STOREG 1
PUSHI 0
STOREG 2
PUSHS "Introduza um número inteiro positivo:"
WRITES
READ
ATOI
STOREG 0
PUSHI 1
STOREG 2
PUSHI 2
STOREG 1
L2:
PUSHG 1
PUSHG 0
PUSHI 2
DIV
INFEQ
PUSHG 2
ADD
PUSHI 2
EQUAL
JZ L3
PUSHG 0
PUSHG 1
MOD
PUSHI 0
EQUAL
JZ L1
PUSHI 0
STOREG 2
L1:
PUSHG 1
PUSHI 1
ADD
STOREG 1
JUMP L2
L3:
PUSHG 2
JZ L4
PUSHG 0
WRITEI
PUSHS " é um número primo"
WRITES
JUMP L5
L4:
PUSHG 0
WRITEI
PUSHS " não é um número primo"
WRITES
L5:
STOP

\end{verbatim}

\section{Teste SomaArray }
O programa soma todos os elementos de um array
\subsection{Código pascal - SomaArray }
\begin{verbatim}
    program SomaArray;
        var  
            numeros: array[1..5] of integer;  
            i, soma: integer;
        begin  
            soma := 0;  
            writeln('Introduza 5 números inteiros:');
            for i := 1 to 5 do
            begin    
                writeln(i);
                readln(numeros[i]);    
                soma := soma + numeros[i];
            end;  
            writeln('A soma dos números é: ', soma);
        end.
\end{verbatim}

\subsection{Código assembly gerado - SomaArray }
\begin{verbatim}
   START
PUSHI 0
STOREG 0
PUSHI 0
STOREG 1
PUSHI 0
STOREG 2
PUSHI 0
STOREG 3
PUSHI 0
STOREG 4
PUSHI 0
STOREG 5
PUSHI 0
STOREG 6
PUSHI 0
STOREG 6
PUSHS "Introduza 5 números inteiros:"
WRITES
PUSHI 1
STOREG 5
L1:
PUSHG 5
PUSHI 5
INFEQ
JZ L2
PUSHGP
PUSHG 5
PUSHI 1
SUB
PUSHI 0
ADD
PADD
READ
ATOI
STORE 0
PUSHG 6
PUSHGP
PUSHG 5
PUSHI 1
SUB
PUSHI 0
ADD
PADD
LOAD 0
ADD
STOREG 6
PUSHG 5
PUSHI 1
ADD
STOREG 5
JUMP L1
L2:
PUSHS "A soma dos números é: "
WRITES
PUSHG 6
WRITEI
STOP
\end{verbatim}



%\VerbatimInput{teste1.txt}

\chapter{Conclusão} \label{concl}
No decorrer do projeto tentamos sempre seguir os métodos de construção de gramáticas aprendidos em sala de aula, o que nos foi bastante útil e permitiu também consolidar o que viemos a aprender durante o semestre. No que diz respeito ao resultado final do projeto, de acordo com o enunciado do mesmo, consideramos que atingimos um bom resultado no que toca à interpretação de funcionalidades simples como operações lógicas, operações aritméticas, variáveis, ciclos e até arrays porém, reconhecemos que para um trabalho mais completo, seria bom termos implementado subprogramas como procedure e function, algo que seria implementado posteriormente como trabalho futuro.


\appendix % apendice
\chapter{Código do Programa}
\begin{lstlisting}[style=pythonStyle, caption={Ficheiro yacc.py}]
import ply.lex as lex

tokens = [
    'PROGRAM', 'VAR', 'BEGIN', 'END', 
    # ciclos e condicionais
    'IF', 'THEN', 'ELSE', 'WHILE', 'DO', 'FOR', 'TO', 
    # funções
    'FUNCTION', 'DIV', 'MOD', 'LENGTH',
    # tipos
    'INTEGER', 'STRING', 'BOOLEAN',
    # bools
    'TRUE', 'FALSE',
    # in&out
    'WRITELN', 'WRITE', 'READLN', 'READ',
    # aritmeticos e relacionais
    'PLUS', 'MINUS', 'TIMES', 'ASSIGN',
    'GT', 'LT', 'EQ', 'NEQ', 'GTE', 'LTE',
    # literals
    'SEMICOLON', 'DOT', 'COLON', 'COMMA', 'LPAREN', 'RPAREN', 'LBRACKET', 'RBRACKET', 'DOTDOT', 'STRING_LITERAL',
    # lógicos
    'AND', 'OR',
    'ARRAY', 'OF',
    'ID', 'NUMBER'
]

t_ignore = ' \r\n\t'
# PR
keywords = {
    'program': 'PROGRAM',
    'var': 'VAR',
    'begin': 'BEGIN',
    'end': 'END',
    'if': 'IF',
    'then': 'THEN',
    'else': 'ELSE',
    'while': 'WHILE',
    'do': 'DO',
    'for': 'FOR',
    'to': 'TO',
    'function': 'FUNCTION',
    'div': 'DIV',
    'mod': 'MOD',
    'integer': 'INTEGER',
    'string': 'STRING',
    'boolean': 'BOOLEAN',
    'true': 'TRUE',
    'false': 'FALSE',
    'writeln': 'WRITELN',
    'write': 'WRITE',
    'readln': 'READLN',
    'read': 'READ',
    'array': 'ARRAY',
    'of': 'OF',
    'and': 'AND',
    'length': 'LENGTH'

}
t_PLUS = r'\+'
t_MINUS = r'-'
t_TIMES = r'\*'
t_ASSIGN = r':='
t_EQ = r'='
t_NEQ = r'<>'
t_GT = r'>'
t_LT = r'<'
t_GTE = r'>='
t_LTE = r'<='
t_COMMA = r','
t_LPAREN = r'\('
t_RPAREN = r'\)'
t_LBRACKET = r'\['
t_RBRACKET = r'\]'
t_SEMICOLON = r';'
t_DOT = r'\.'
t_COLON = r':'
t_DOTDOT = r'\.\.'
t_OR = r'or'
t_AND = r'and'

def t_STRING_LITERAL(t):
    r"'[^']*'"
    t.value = t.value[1:-1]
    return t

def t_MOD(t):
    r'mod'
    t.type="MOD"
    return t

def t_DIV(t):
    r'div'
    t.type="DIV"
    return t

def t_COMMENT(t):
    r'(\{.*?\})|(\(\*.*?\*\))'
    pass 

def t_NUMBER(t):
    r'\d+\.\d+|\d+' 
    if '.' in t.value:
        t.value = float(t.value)
    else:
        t.value = int(t.value)
    return t

def t_ARRAY(t):
    r'array'
    t.type="ARRAY"
    return t

def t_OF(t):
    r'of'
    t.type="OF"
    return t

def t_PROGRAM(t):
    r'program'
    t.type = 'PROGRAM'
    return t

def t_VAR(t):
    r'var'
    t.type = 'VAR'
    return t

def t_BEGIN(t):
    r'begin'
    t.type = 'BEGIN'
    return t

def t_END(t):
    r'end'
    t.type = 'END'
    return t

def t_IF(t):
    r'if'
    t.type = 'IF'
    return t

def t_THEN(t):
    r'then'
    t.type = 'THEN'
    return t

def t_ELSE(t):
    r'else'
    t.type = 'ELSE'
    return t

def t_WHILE(t):
    r'while'
    t.type = 'WHILE'
    return t

def t_DO(t):
    r'do'
    t.type = 'DO'
    return t

def t_FOR(t):
    r'for'
    t.type = 'FOR'
    return t

def t_TO(t):
    r'to'
    t.type = 'TO'
    return t

def t_FUNCTION(t):
    r'function'
    t.type = 'FUNCTION'
    return t

def t_INTEGER(t):
    r'integer'
    t.type = 'INTEGER'
    return t

def t_STRING(t):
    r'string'
    t.type = 'STRING'
    return t

def t_BOOLEAN(t):
    r'boolean'
    t.type = 'BOOLEAN'
    return t

def t_TRUE(t):
    r'true'
    t.type = 'TRUE'
    return t

def t_FALSE(t):
    r'false'
    t.type = 'FALSE'
    return t

def t_WRITELN(t):
    r'writeln'
    t.type = 'WRITELN'
    return t

def t_WRITE(t):
    r'write'
    t.type = 'WRITE'
    return t

def t_READLN(t):
    r'readln'
    t.type = 'READLN'
    return t

def t_READ(t):
    r'read'
    t.type = 'READ'
    return t

def t_ID(t):
    r'[a-zA-Z_][a-zA-Z0-9_]*'
    t.value = t.value.lower()
    t.type = keywords.get(t.value, 'ID')
    return t

def t_error(t):
    print(f'Illegal character: {t.value[0]}')
    t.lexer.skip(1)

lexer = lex.lex()

\end{lstlisting}

\begin{lstlisting}[style=pythonStyle, caption={Ficheiro lex.py}]
import ply.yacc as yacc
from lex import tokens
import sys
import argparse

symbol_table_stack = [{}] # stack vars  
current_scope_level = 0 # distingue global e local
stack_pointer = 0 
local_offset = 0 
label_counter = 0
current_function = None
function_table = {} # simbols de funções

def new_label():
    global label_counter
    label_counter += 1
    return f"L{label_counter}"

def add_symbol(name, sym_type, is_array=False, array_range=None, is_local=False, offset=None):
    global stack_pointer, local_offset
    name = name.lower()
    if name in symbol_table_stack[current_scope_level]:
        return None 
    symbol = {'type': sym_type, 'is_array': is_array}
    if is_local:
        if is_array:
            print("Error: Arrays not supported as local variables")
            return None
        symbol['offset'] = local_offset
        symbol['is_local'] = True
        local_offset += 1
    else:
        if is_array:
            low, high = array_range
            size = high - low + 1
            symbol['range'] = array_range
            symbol['size'] = size
            symbol['offset'] = stack_pointer
            stack_pointer += size
        else:
            symbol['offset'] = stack_pointer if offset is None else offset
            if offset is None:
                stack_pointer += 1
    symbol_table_stack[current_scope_level][name] = symbol
    return symbol

def get_symbol(name):
    name = name.lower()
    for scope in reversed(symbol_table_stack):
        if name in scope:
            return scope[name]
    return None

def p_Program(p):
    '''Program : PROGRAM ID SEMICOLON Block DOT'''
    p[0] = f"START\n{p[4]}STOP\n"

def p_Block(p):
    '''Block : Declarations CompoundStatement'''
    p[0] = f"{p[1]}{p[2]}"

def p_Declarations(p):
    '''Declarations : VarDeclarationPart FunctionDeclarations'''
    p[0] = f"{p[1]}{p[2]}"

def p_VarDeclarationPart(p):
    '''VarDeclarationPart : VAR VarDeclarationList
                          | empty'''
    p[0] = p[2] if len(p) == 3 else ""

def p_VarDeclarationList(p):
    '''VarDeclarationList : VarDeclaration
                          | VarDeclarationList VarDeclaration'''
    p[0] = p[1] if len(p) == 2 else f"{p[1]}{p[2]}"

def p_VarDeclaration(p):
    '''VarDeclaration : IdList COLON Type SEMICOLON'''
    ids = p[1]
    var_type = p[3]
    code = ""
    for var_name in ids:
        if current_function is not None:
            if isinstance(var_type, tuple) and var_type[0] == 'array':
                print("Error: Arrays not supported as local variables")
                p[0] = ""
                return
            add_symbol(var_name, var_type, is_local=True)
        else:
            if isinstance(var_type, tuple) and var_type[0] == 'array':
                base_type = var_type[1]
                array_range = var_type[2]
                symbol = add_symbol(var_name, base_type, is_array=True, array_range=array_range)
                if symbol:
                    for i in range(array_range[1] - array_range[0] + 1):
                        code += f"PUSHI 0\nSTOREG {symbol['offset'] + i}\n"
            else:
                symbol = add_symbol(var_name, var_type)
                if symbol:
                    code += f"PUSHI 0\nSTOREG {symbol['offset']}\n"
    p[0] = code

def p_IdList(p):
    '''IdList : ID
              | ID COMMA IdList'''
    p[0] = [p[1]] if len(p) == 2 else [p[1]] + p[3]

def p_Type(p):
    '''Type : BasicType
            | ArrayType'''
    p[0] = p[1]

def p_BasicType(p):
    '''BasicType : INTEGER
                 | STRING
                 | BOOLEAN'''
    p[0] = p[1].lower()

def p_ArrayType(p):
    '''ArrayType : ARRAY LBRACKET NUMBER DOTDOT NUMBER RBRACKET OF BasicType'''
    low = int(p[3])
    high = int(p[5])
    base_type = p[8].lower()
    p[0] = ('array', base_type, (low, high))

def p_FunctionDeclarations(p):
    '''FunctionDeclarations : FunctionDeclaration FunctionDeclarations
                            | empty'''
    p[0] = p[1] + p[2] if len(p) == 3 else ""

def p_FunctionDeclaration(p):
    '''FunctionDeclaration : FUNCTION ID LPAREN FormalParameters RPAREN COLON BasicType SEMICOLON Declarations CompoundStatement'''
    global current_function, local_offset
    func_name = p[2].lower()
    params = p[4]
    return_type = p[7].lower()
    local_decls = p[9]
    body = p[10]
    func_label = new_label()
    function_table[func_name] = {'label': func_label, 'params': params, 'return_type': return_type}
    old_offset = local_offset
    local_offset = 1
    symbol_table_stack.append({})
    current_scope_level += 1
    current_function = func_name
    number_of_params = len(params)
    return_offset = -(number_of_params + 1)
    add_symbol(func_name, return_type, is_local=False, offset=return_offset)
    for i, param in enumerate(params):
        param_name, param_type = param
        offset = -number_of_params + i
        add_symbol(param_name, param_type, is_local=False, offset=offset)
    local_decls_code = local_decls
    number_of_locals = local_offset - 1
    func_code = f"{func_label}:\nPUSHN {number_of_locals}\n{local_decls_code}{body}RETURN\n"
    symbol_table_stack.pop()
    current_scope_level -= 1
    local_offset = old_offset
    current_function = None
    p[0] = func_code

def p_FormalParameters(p):
    '''FormalParameters : ID COLON Type
                        | ID COLON Type SEMICOLON FormalParameters
                        | empty'''
    if len(p) == 2:
        p[0] = []
    elif len(p) == 4:
        p[0] = [(p[1], p[3])]
    else:
        p[0] = [(p[1], p[3])] + p[5]

def p_CompoundStatement(p):
    '''CompoundStatement : BEGIN StatementList END'''
    p[0] = p[2]

def p_StatementList(p): 
    '''StatementList : Statement
                     | StatementList SEMICOLON Statement'''
    p[0] = p[1] if len(p) == 2 else f"{p[1]}{p[3]}"

def p_Statement(p):
    '''Statement : AssignmentStatement
                 | WriteStatement
                 | ReadStatement
                 | IfStatement
                 | WhileStatement
                 | ForStatement
                 | CompoundStatement
                 | empty'''
    p[0] = p[1]

def p_ReadStatement(p):
    '''ReadStatement : READLN LPAREN ArrayAccess RPAREN
                     | READLN LPAREN ID RPAREN'''
    if p[3][0] == 'array_access':
        var_name, index_code, index_type = p[3][1:]
        symbol = get_symbol(var_name)
        if not symbol or not symbol.get('is_array'):
            print(f"Error: '{var_name}' is not an array")
            p[0] = ""
            return
        if index_type != 'integer':
            print(f"Error: Array index must be integer")
            p[0] = ""
            return
        if symbol['type'] != 'integer':
            print(f"Error: Array elements must be integer for READLN")
            p[0] = ""
            return
        low = symbol['range'][0]
        offset = symbol['offset']
        p[0] = f"PUSHGP\n{index_code}PUSHI {low}\nSUB\nPUSHI {offset}\nADD\nPADD\nREAD\nATOI\nSTORE 0\n"
    else:
        var_name = p[3].lower()
        symbol = get_symbol(var_name)
        if not symbol:
            print(f"Error: Variable '{var_name}' not declared")
            p[0] = ""
            return
        if symbol.get('is_array'):
            print(f"Error: '{var_name}' is an array; use array indexing")
            p[0] = ""
            return
        if symbol['type'] != 'integer':
            print(f"Error: Variable must be integer for READLN")
            p[0] = ""
            return
        offset = symbol['offset']
        p[0] = f"READ\nATOI\nSTOREG {offset}\n"

def p_AssignmentStatement(p):
    '''AssignmentStatement : ID ASSIGN Expression
                          | ArrayAccess ASSIGN Expression'''
    global current_function
    if p[1][0] == 'array_access':
        var_name, index_code, index_type = p[1][1:]
        expr_code, expr_type = p[3]
        symbol = get_symbol(var_name)
        if not symbol or not symbol.get('is_array'):
            print(f"Error: '{var_name}' is not an array")
            p[0] = ""
            return
        if index_type != 'integer':
            print(f"Error: Array index must be integer")
            p[0] = ""
            return
        if symbol['type'] != expr_type:
            print(f"Error: Type mismatch in array assignment")
            p[0] = ""
            return
        low = symbol['range'][0]
        offset = symbol['offset']
        p[0] = f"PUSHGP\n{index_code}PUSHI {low}\nSUB\nPUSHI {offset}\nADD\nPADD\n{expr_code}STORE 0\n"
    else:
        var_name = p[1].lower()
        expr_code, expr_type = p[3]
        symbol = get_symbol(var_name)
        if not symbol:
            print(f"Error: Variable '{var_name}' not declared")
            p[0] = ""
            return
        if symbol.get('is_array'):
            print(f"Error: '{var_name}' is an array; use array indexing")
            p[0] = ""
            return
        if symbol['type'] != expr_type:
            print(f"Error: Type mismatch in assignment")
            p[0] = ""
            return
        offset = symbol['offset']
        if var_name == current_function:
            number_of_params = len(function_table[current_function]['params'])
            p[0] = f"{expr_code}STOREL -{number_of_params + 1}\n"
        elif symbol.get('is_local'):
            p[0] = f"{expr_code}STOREL {offset}\n"
        else:
            p[0] = f"{expr_code}STOREG {offset}\n"

def p_WriteStatement(p):
    '''WriteStatement : WRITELN LPAREN ExpressionList RPAREN'''
    code = ""
    for expr in p[3]:
        expr_code, expr_type = expr
        if expr_type == 'integer':
            code += f"{expr_code}WRITEI\n"
        elif expr_type == 'string':
            code += f"{expr_code}WRITES\n"
        else:
            print(f"Error: Unsupported type '{expr_type}' for WRITELN")
            p[0] = ""
            return
    p[0] = code

def p_ExpressionList(p):
    '''ExpressionList : Expression
                      | ExpressionList COMMA Expression'''
    if len(p) == 2:
        p[0] = [p[1]]
    else:
        p[0] = p[1] + [p[3]]

def p_Expression_length(p):
    '''Expression : LENGTH LPAREN Expression RPAREN'''
    expr_code, expr_type = p[3]
    if expr_type != 'string':
        print("Error: length() argument must be a string")
        p[0] = ("", 'error')
        return
    p[0] = (f"{expr_code}STRLEN\n", 'integer')

def p_Expression_function_call(p):
    '''Expression : ID LPAREN ActualParameters RPAREN'''
    func_name = p[1].lower()
    if func_name == 'length':
        print("Error: 'length' is a reserved function name")
        p[0] = ("", 'error')
        return
    if func_name not in function_table:
        print(f"Error: Undeclared function '{func_name}'")
        p[0] = ("", 'error')
        return
    func_info = function_table[func_name]
    args = p[3]
    if len(args) != len(func_info['params']):
        print(f"Error: Argument count mismatch for '{func_name}'")
        p[0] = ("", 'error')
        return
    arg_code = ""
    for arg, param in zip(args, func_info['params']):
        arg_code += arg[0]
        if arg[1] != param[1]:
            print(f"Error: Type mismatch in argument for '{func_name}'")
            p[0] = ("", 'error')
            return
    call_code = f"PUSHI 0\n{arg_code}PUSHA {func_info['label']}\nCALL\n"
    p[0] = (call_code, func_info['return_type'])

def p_IfStatement_then(p):
    '''IfStatement : IF Expression THEN Statement'''
    cond_code, cond_type = p[2]
    if cond_type != 'boolean':
        print("Error: Condition must be boolean")
        p[0] = ""
        return
    then_code = p[4]
    end_label = new_label()
    p[0] = f"{cond_code}JZ {end_label}\n{then_code}{end_label}:\n"

def p_IfStatement_else(p):
    '''IfStatement : IF Expression THEN Statement ELSE Statement'''
    cond_code, cond_type = p[2]
    if cond_type != 'boolean':
        print("Error: Condition must be boolean")
        p[0] = ""
        return
    then_code = p[4]
    else_code = p[6]
    else_label = new_label()
    end_label = new_label()
    p[0] = f"{cond_code}JZ {else_label}\n{then_code}JUMP {end_label}\n{else_label}:\n{else_code}{end_label}:\n"

def p_WhileStatement(p):
    '''WhileStatement : WHILE Expression DO Statement'''
    start_label = new_label()
    end_label = new_label()
    print(p[2])
    cond_code, cond_type = p[2]
    if cond_type != 'boolean':
        print("Error: While condition must be boolean")
        p[0] = ""
        return
    body_code = p[4]
    p[0] = f"{start_label}:\n{cond_code}JZ {end_label}\n{body_code}JUMP {start_label}\n{end_label}:\n"

def p_ForStatement(p):
    '''ForStatement : FOR ID ASSIGN Expression TO Expression DO Statement'''
    var_name = p[2].lower()
    init_code, init_type = p[4]
    end_code, end_type = p[6]
    body_code = p[8]
    symbol = get_symbol(var_name)
    if not symbol:
        print(f"Error: Variable '{var_name}' not declared")
        p[0] = ""
        return
    if symbol.get('is_array'):
        print(f"Error: Loop variable '{var_name}' cannot be an array")
        p[0] = ""
        return
    if init_type != 'integer' or end_type != 'integer':
        print(f"Error: FOR loop bounds must be integers")
        p[0] = ""
        return
    if symbol['type'] != 'integer':
        print(f"Error: Loop variable must be integer")
        p[0] = ""
        return
    offset = symbol['offset']
    start_label = new_label()
    end_label = new_label()
    load_op = 'PUSHL' if symbol.get('is_local') else 'PUSHG'
    store_op = 'STOREL' if symbol.get('is_local') else 'STOREG'
    p[0] = (
        f"{init_code}{store_op} {offset}\n"
        f"{start_label}:\n"
        f"{load_op} {offset}\n"
        f"{end_code}"
        f"INFEQ\n"
        f"JZ {end_label}\n"
        f"{body_code}"
        f"{load_op} {offset}\n"
        f"PUSHI 1\n"
        f"ADD\n"
        f"{store_op} {offset}\n"
        f"JUMP {start_label}\n"
        f"{end_label}:\n"
    )

def p_Expression_number(p):
    '''Expression : NUMBER'''
    p[0] = (f"PUSHI {p[1]}\n", 'integer')

def p_Expression_group(p):
    '''Expression : LPAREN Expression RPAREN'''
    p[0] = p[2]

def p_Expression_boolean(p):
    '''Expression : TRUE
                  | FALSE'''
    p[0] = ("PUSHI 1\n", 'boolean') if p[1].lower() == 'true' else ("PUSHI 0\n", 'boolean')

def p_Expression_string(p):
    '''Expression : STRING_LITERAL'''
    p[0] = (f"PUSHS \"{p[1]}\"\n", "string")

def p_Expression_id(p):
    '''Expression : ID'''
    var_name = p[1].lower()
    symbol = get_symbol(var_name)
    if not symbol:
        print(f"Error: Undeclared variable '{var_name}'")
        p[0] = ("", 'error')
        return
    if symbol.get('is_array'):
        print(f"Error: '{var_name}' is an array; use array indexing")
        p[0] = ("", 'error')
        return
    op = 'PUSHL' if symbol.get('is_local') else 'PUSHG'
    p[0] = (f"{op} {symbol['offset']}\n", symbol['type'])

def p_Expression_array_access(p):
    '''Expression : ID LBRACKET Expression RBRACKET'''
    var_name = p[1].lower()
    index_code, index_type = p[3]
    symbol = get_symbol(var_name)
    if not symbol:
        print(f"Error: Undeclared variable '{var_name}'")
        p[0] = ("", 'error')
        return
    if symbol.get('is_array'):
        if index_type != 'integer':
            print(f"Error: Array index must be integer")
            p[0] = ("", 'error')
            return
        low = symbol['range'][0]
        offset = symbol['offset']
        code = f"PUSHGP\n{index_code}PUSHI {low}\nSUB\nPUSHI {offset}\nADD\nPADD\nLOAD 0\n"
        p[0] = (code, symbol['type'])
    elif symbol['type'] == 'string':
        if index_type != 'integer':
            print(f"Error: String index must be integer")
            p[0] = ("", 'error')
            return
        load_op = 'PUSHL' if symbol.get('is_local') else 'PUSHG'
        code = f"{load_op} {symbol['offset']}\n{index_code}PUSHI 1\nSUB\nCHARAT\n"
        p[0] = (code, 'integer')
    else:
        print(f"Error: '{var_name}' is not an array or string")
        p[0] = ("", 'error')

def p_Expression_function_call(p):
    '''Expression : ID LPAREN ActualParameters RPAREN'''
    func_name = p[1].lower()
    if func_name not in function_table:
        print(f"Error: Undeclared function '{func_name}'")
        p[0] = ("", 'error')
        return
    func_info = function_table[func_name]
    args = p[3]
    if len(args) != len(func_info['params']):
        print(f"Error: Argument count mismatch for '{func_name}'")
        p[0] = ("", 'error')
        return
    arg_code = ""
    for arg, param in zip(args, func_info['params']):
        arg_code += arg[0]
        if arg[1] != param[1]:
            print(f"Error: Type mismatch in argument for '{func_name}'")
            p[0] = ("", 'error')
            return
    call_code = f"PUSHI 0\n{arg_code}PUSHA {func_info['label']}\nCALL\n"
    p[0] = (call_code, func_info['return_type'])

def p_ActualParameters(p):
    '''ActualParameters : Expression
                        | Expression COMMA ActualParameters
                        | empty'''
    if len(p) == 2:
        p[0] = [] if p[1] == '' else [p[1]]
    else:
        p[0] = [p[1]] + p[3]

def p_Expression_binop(p):
    '''Expression : Expression PLUS Expression
                  | Expression MINUS Expression
                  | Expression TIMES Expression'''
    code1, type1 = p[1]
    op = p[2]
    code3, type3 = p[3]
    if type1 == 'integer' and type3 == 'integer':
        op_code = {'+': 'ADD', '-': 'SUB', '*': 'MUL'}[op]
        p[0] = (f"{code1}{code3}{op_code}\n", 'integer')
    else:
        print("Error: Type mismatch in expression")
        p[0] = ("", 'error')

def p_Expression_moddiv(p):
    '''Expression : Expression MOD Expression
                  | Expression DIV Expression'''
    code1, t1 = p[1]
    code3, t2 = p[3]
    if t1 == t2 == 'integer':
        p[0] = (f"{code1}{code3}{p[2]}\n", 'integer')
    else:
        print("Error: Type mismatch in mod/div")
        p[0] = ("", 'error')

def p_Expression_rel(p):
    '''Expression : Expression LT Expression
                  | Expression GT Expression
                  | Expression EQ Expression
                  | Expression NEQ Expression
                  | Expression LTE Expression
                  | Expression GTE Expression'''
    code1, type1 = p[1]
    op = p[2]
    code3, type3 = p[3]
    if type1 == type3 and type1 in ('integer', 'boolean'):
        op_code = {'<': 'INF', '>': 'SUP', '=': 'EQUAL', '<>': 'NOTEQUAL', '<=': 'INFEQ', '>=': 'SUPEQ'}[op]
        p[0] = (f"{code1}{code3}{op_code}\n", 'boolean')
    else:
        print("Error: Type mismatch in relational expression")
        p[0] = ("", 'error')

def p_Expression_log(p):
    '''Expression : Expression AND Expression
                  | Expression OR Expression'''
    code1, type1 = p[1]
    op = p[2]
    code3, type3 = p[3]
    if type1 == 'boolean' and type3 == 'boolean':
        if op == "and":
            p[0] = (f"{code1}{code3}ADD\nPUSHI 2\nEQUAL\n", 'boolean')
        elif op == "or":
            p[0] = (f"{code1}{code3}ADD\nPUSHI 1\nSUPEQ\n", 'boolean')
    else:
        print("Error: Type mismatch in logical expression")
        p[0] = ("", 'error')

def p_ArrayAccess(p):
    '''ArrayAccess : ID LBRACKET Expression RBRACKET'''
    var_name = p[1].lower()
    index_code, index_type = p[3]
    p[0] = ('array_access', var_name, index_code, index_type)

def p_empty(p):
    '''empty :'''
    p[0] = ""

def p_error(p):
    print("Syntax error")

parser = yacc.yacc()
parser.exito = True

PREMADE_EXAMPLES = {
    "MaiorDe3": """
        program Maior3;
        var  
            num1, num2, num3, maior: integer;
        begin
            { Ler 3 números }
            writeln('Introduza o primeiro número: ');  
            readln(num1);
            writeln('Introduza o segundo número: ');  
            readln(num2);
            writeln('Introduza o terceiro número: ');  
            readln(num3);
            if num1 > num2 then
                if num1 > num3 then 
                    maior := num1
                else maior := num3
            elseif num2 > num3 
                then maior := num2
            else 
                maior := num3;
            writeln(maior);
        end.
    """,

    "Fatorial": """
        program Fatorial;
        var  
            n, i, fat: integer;
        begin  
            writeln('Introduza um número inteiro positivo:');  
            readln(n);
            fat := 1;
            for i := 1 to n do    
                fat := fat * i;
            writeln('Fatorial de ', n, ': ', fat);
        end.
    """,

    "NumeroPrimo": """
        program NumeroPrimo;
        var  
            num, i: integer;  
            primo: boolean;
        begin  
            writeln('Introduza um número inteiro positivo:');  
            readln(num);  
            primo := true;  
            i := 2;
            while (i <= (num div 2)) and primo do
                begin
                    if (num mod i) = 0 then            
                        primo := false;        
                    i := i + 1;
                end;
            if primo then    
                writeln(num, ' é um número primo')
            else    
                writeln(num, ' não é um número primo');
        end.
    """,

    "SomaArray": """
        program SomaArray;
        var  
            numeros: array[1..5] of integer;  
            i, soma: integer;
        begin  
            soma := 0;  
            writeln('Introduza 5 números inteiros:');
            for i := 1 to 5 do
            begin    
                writeln(i);
                readln(numeros[i]);    
                soma := soma + numeros[i];
            end;  
            writeln('A soma dos números é: ', soma);
        end.
    """, 
    "HelloWorld": """
    program HelloWorld;
        begin
        writeln('Ola, Mundo!');
    end.
    """
    
}

def main():
    parser_args = argparse.ArgumentParser(
        description="Compile Pascal‐like source code into intermediate instructions."
    )

    group = parser_args.add_mutually_exclusive_group()
    group.add_argument(
        "-e", "--example",
        choices=list(PREMADE_EXAMPLES.keys()),
        help="Name of a premade example to compile"
    )
    group.add_argument(
        "-f", "--file",
        metavar="PATH",
        help="Path to a source‐file to compile"
    )

    args = parser_args.parse_args()

    if args.example:
        source_code = PREMADE_EXAMPLES[args.example]
        print(f"*** Compiling example: {args.example} ***\n")
    elif args.file:
        try:
            with open(args.file, 'r', encoding='utf-8') as fp:
                source_code = fp.read()
            print(f"*** Compiling file: {args.file} ***\n")
        except IOError as e:
            print(f"Error: could not open file '{args.file}': {e}")
            sys.exit(1)
    else:
        print("*** Reading source code from stdin (terminate with EOF) ***\n")
        source_code = sys.stdin.read()

    global symbol_table_stack, current_scope_level, stack_pointer
    global local_offset, label_counter, current_function, function_table

    symbol_table_stack = [{}]
    current_scope_level = 0
    stack_pointer = 0
    local_offset = 0
    label_counter = 0
    current_function = None
    function_table = {}

    result = parser.parse(source_code, debug=False)

    if result is None:
        print("Parsing returned None (likely a syntax error).")
        sys.exit(1)
    else:
        print("=== generated intermediate code ===\n")
        print(result)

if __name__ == "__main__":
    main()
\end{lstlisting}
\end{document}









\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{glossaries}

\makeglossaries

\newglossaryentry{latex}
{
    name=latex,
    description={Is a mark up language specially suited
    for scientific documents}
}

\newglossaryentry{maths}
{
    name=mathematics,
    description={Mathematics is what mathematicians do}
}

\title{How to create a glossary}
\author{ }
\date{ }

\begin{document}
\maketitle

The \Gls{latex} typesetting markup language is specially suitable
for documents that include \gls{maths}.

\clearpage

\printglossaries

\end{document}
